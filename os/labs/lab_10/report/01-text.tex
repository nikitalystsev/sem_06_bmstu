\chapter{Структуры}

Версия ядра: \texttt{6.5.0-32-generic}.

\includelisting
{IOFILE_1.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Структура struct \_IO\_FILE (начало)} % Подпись листинга

\clearpage 

\includelisting
{IOFILE_2.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Структура struct \_IO\_FILE (конец)} % Подпись листинга

\includelisting
{structstat.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Структура struct stat} % Подпись листинга

\chapter{Программы}

\section{Первая программа}

\includelisting
{1.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Первая программа} % Подпись листинга

\includeimage
{res_1} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результат выполнения программы} % Подпись рисунка

% \includeimage{res_1}{f}{h}{0.9\textwidth}{Результат выполнения программы}

\clearpage 

В первой программе файл открывается только для чтения (O\_RDONLY)
Cистемный вызов open() создает дескриптор открытого файла.
Системный вызов open() возвращает индекс элемента в массиве fd\_array структуры files\_struct.
Индекс равен 3, так как элементы массива fd\_array с индексами 0, 1, 2 инициализированы стандартными потоками stdin, stdout, stderr.
Библиотечная функция fdopen() возвращает указатели на структуры struct FILE (fs1, fs2), поля которых указывают на дескриптор fd, созданный системным вызовом open().
Создаются буферы buff1, buff2 размером 20 байт.
Функция setvbuf() для дескрипторов fs1, fs2 задает буферы buff1, buff2 с типом буферизации \_IOFBF.

При первом вызове fscanf() для fs1 в буфер buff1 считываются первые 20 символов.
Значение f\_pos в структуре struct\_file открытого файла увеличивается на 20.
В переменную c записывается символ 'a', значение переменной c выводится на экран функцией fprintf().
При первом вызове fscanf() для fs2 в буфер buff2 считываются оставшиеся в файле символы.
В переменную c записывается символ 'u', значение переменной c выводится на экран функцией fprintf().
 
В цикле символы из buff1, buff2 будут поочередно выводиться на экран, пока один из буферов не будет пуст.
В этом случае оставшиеся символы из второго буфера будут последовательно выведены на экран.

\includeimage{diagram_1_rotated}{f}{h}{0.9\textwidth}{Связи структур в первой программе}

\clearpage

\section{Вторая программа, первый вариант}

\subsection{Без использования потоков}

\includelisting
{2.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Вторая программа, первый вариант} % Подпись листинга

\includeimage
{res_2} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результат выполнения программы} % Подпись рисунка

% \includeimage{res_2}{f}{h}{0.7\textwidth}{Результат выполнения программы}

Во второй программе один и тот же файл открывается два раза только для чтения (O\_RDONLY).
Системный вызов open() создает дескриптор открытого файла в таблице открытых файлов процесса и запись в системной таблице открытых файлов.
Так как файл открывается дважды, то в системной таблице создается два дескриптора struct file, каждый из которых имеет собственный указатель f\_pos.
Таким образом, в данном случае чтение из файла является независимым: при поочередном вызове read() для каждого дескриптора соответствующие указатели f\_pos проходят по всем позициям файла, каждый символ считывается и выводится по два раза.

\includeimage{diagram_2_rotated}{f}{h}{0.9\textwidth}{Связи структур во второй  программе}

\clearpage

\subsection{С использованием двух дополнительных потоков}

\includelisting
{2_thread.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Вторая программа, первый вариант (два дополнительных потока)} % Подпись листинга

\clearpage

\includeimage
{res_2_thread} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Результат выполнения программы} % Подпись рисунка

% \includeimage{res_2_thread}{f}{h}{0.6\textwidth}{Результат выполнения программы}

В многопоточной версии программы порядок вывода символов не определен, так как потоки выполняются параллельно (асинхронно).
В случае с главным и дополнительным потоками дополнительный поток начинает выполнение позже главного, так как на его создание затрачивается время.

\clearpage

\section{Вторая программа, второй вариант}

\subsection{Без использования потоков}

\includelisting
{2_1.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Вторая программа, второй вариант} % Подпись листинга

\clearpage


\includeimage
{res_2_1} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{0.6\textwidth} % Ширина рисунка
{Результат выполнения программы} % Подпись рисунка

% \includeimage{res_2_1}{f}{h}{0.6\textwidth}{Результат выполнения программы}

В программе один и тот же файл ("q.txt") открывается дважды для чтения и записи (O\_RDWR).
Системный вызов open() создает дескриптор открытого файла в таблице открытых файлов процесса и запись в системной таблице открытых файлов.
Так как файл открывается дважды, то в системной таблице создается два дескриптора struct file, каждый из которых имеет собственный указатель f\_pos.
При первом вызове write() для fd1 символ 'a' записывается в файл на 0 позицию и соответствующий указатель f\_pos увеличивается на 1.
При первом вызове write() для fd2 символ 'b' также записывается в файл на 0 позицию и соответствующий указатель f\_pos увеличивается на 1.
Таким образом, при поочередной записи символов в файл он будет содержать только символы, которые записывались через fd2.
Произошла потеря данных.

\clearpage 

Чтобы избежать потерю данных, файл можно дважды открыть для чтения, записи и добавления записи в конец (O\_RDWR | O\_APPEND).
При первом вызове write() для fd1 символ 'a' записывается в файл на последнюю позицию (0).
При первом вызове write() для fd2 символ 'b' также записывается в файл на последнюю позицию (1).
Таким образом, при поочередной записи символов в файл он будет содержать все символы алфавита.

\clearpage

\subsection{С использованием двух дополнительных потоков}

\includelisting
{2_1_thread_1.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Вторая программа, второй вариант (два дополнительных потока) (начало)} % Подпись листинга

\includelisting
{2_1_thread_2.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Вторая программа, второй вариант (два дополнительных потока) (конец)} % Подпись листинга

\includeimage{res_2_1_thread}{f}{h}{0.6\textwidth}{Результат выполнения программы}

\clearpage 

В многопоточной версии программы потоки выполняются параллельно (асинхронно).
Однако потеря данных полностью аналогична той, что однопоточной версии программы: при первом вызове write() для fd[0] (первый поток) символ 'a' записывается в файл на 0 позицию и соответствующий указатель f\_pos увеличивается на 1; при первом вызове write() для fd[1] (второй поток) символ 'b' также записывается в файл на 0 позицию и соответствующий указатель f\_pos увеличивается на 1.
Таким образом, при поочередной записи символов в файл он будет содержать только символы, которые записывались вторым потоком.

Чтобы избежать потерю данных, файл можно дважды открыть для чтения, записи и записи в конец (O\_RDWR | O\_APPEND).
При первом вызове write() для fd[0] (первый поток) символ 'a' записывается в файл на последнюю позицию (0).
При первом вызове write() для fd[1] (второй поток) символ 'b' также записывается в файл на последнюю позицию (1).
Таким образом, при поочередной записи символов в файл он будет содержать все символы алфавита.
Порядок символов не определен, так как потоки выполняются параллельно (асинхронно).

\clearpage

\section{Третья программа}

\includelisting
{3.c} % Имя файла с расширением (файл должен быть расположен в директории inc/lst/)
{Третья программа} % Подпись листинга

\includeimage{res_3}{f}{h}{0.6\textwidth}{Результат выполнения программы}

В третьей программе файл дважды открывается на чтение и запись функцией fopen() из библиотеки буферизованного ввода--вывода stdio.h.
В результате выполнения fopen() в системной таблице открытых файлов создаются два дескриптора struct file, каждый из которых имеет собственный указатель f\_pos, при этом оба дескриптора ссылаются на один и тот же inode.
Библиотечная функция fprintf() выполняет буферизованный вывод.
При этом буфер создается неявно.
Данные из буфера записываются в файл по трем причинам:

\begin{enumerate}
	\item буфер заполнен,
	\item вызвана функция fflush() (принудительная запись),
	\item вызвана функция close() / fclose().
\end{enumerate}

В данном случае запись в файл происходит в результате вызова функции fclose().
При вызове fclose() для fs1 буфер для fs1 записывается в файл.
При вызове fclose() для fs2 все содержимое файла очищается и буфер для fs2 записывается в файл.
Таким образом, произошла потеря данных, так как в файле находится только содержимое буфера для fs2.

Чтобы избежать потерю данных, при втором открытии файла можно указать режим записи в конец файла ("a").
В таком случае содержимое при вызове fclose() для fs2 содержимое файла не будет очищаться, а содержимое буфера для fs2 будет добавлено в конец файла.

\includeimage{diagram_3_rotated}{f}{h}{0.9\textwidth}{Связи структур в третьей программе}